# 7. Sub-Items & Nested Commands\n\nActionCore facilitates the creation of hierarchical command structures through the `subItems` property in `ActionDefinition`. This allows an action to act as a container or a group, which, when invoked or expanded in a UI, reveals a list of further executable actions. This feature is fundamental for building UIs like command palettes with nested menus, dynamic navigation systems, or context-sensitive action groups.\n\n## The `subItems` Property\n\nThe `subItems` property in an `ActionDefinition` is a function that returns an array of `ActionDefinition` objects, or a `Promise` that resolves to such an array.\n\n```typescript\n// From ActionDefinition in types.ts\nexport interface ActionDefinition<T extends ActionContext = ActionContext> {\n  // ... other properties (id, title, etc.)\n  handler?: (context: T) => void | Promise<void>;\n  subItems?: (context: T) => ActionDefinition<T>[] | Promise<ActionDefinition<T>[]>;\n}\n```\n\n*   **Type:** `(context: ActionContext) => ActionDefinition[] | Promise<ActionDefinition[]>`\n*   **`context: ActionContext`:** The function receives the `ActionContext` of the parent action\'s invocation. This allows the list of sub-items to be dynamically generated based on the context in which the parent group action was triggered.\n*   **Return Value:**\n    *   `ActionDefinition[]`: A synchronous array of further action definitions.\n    *   `Promise<ActionDefinition[]>`: For cases where sub-items need to be fetched asynchronously (e.g., from an API, or based on other async operations).\n\n**Key Characteristics:**\n\n*   **No Direct Handler (Usually):** An action that primarily serves to provide `subItems` often won\'t have a `handler` itself. Its purpose is to expose the next level of actions.\n    *   If `actionCore.executeAction()` is called on an action that *only* has `subItems` and no `handler`, ActionCore currently logs a debug message and does nothing further. The responsibility of invoking the `subItems` function and displaying the resulting actions lies with the UI component (e.g., a command palette) that is interacting with this group action.\n*   **Recursive Structure:** Sub-items themselves can also have `subItems`, allowing for arbitrarily deep nesting of commands. However, for usability, aim for shallower hierarchies (see [Best Practices](./10-best-practices.md) and [Anti-Patterns](./11-anti-patterns.md)).\n\n## Use Cases\n\n1.  **Command Palette Navigation:**\n    *   A top-level action like \"File...\" or \"Preferences...\" in a command palette.\n    *   When selected, its `subItems` function is called to populate the palette with actual file operations (\"Open\", \"Save\", \"Close\") or specific preference categories.\n\n2.  **Dynamic Menus:**\n    *   A \"Go to Recent Document...\" action where `subItems` dynamically fetches and returns actions representing the 5 most recently opened files.\n\n3.  **Contextual Action Groups:**\n    *   An action \"Format Selection...\" whose `subItems` might present different formatting options based on the type of content currently selected in an editor (passed via `ActionContext.data`).\n\n4.  **Developer Tools/Feature Flags:**\n    *   An action \"Toggle Feature Flag...\" where `subItems` calls an API to get all available feature flags and presents each as a sub-action to toggle its state.\n\n## Examples\n\n### Synchronous Sub-Items\n\n```typescript\nimport type { ActionDefinition, ActionContext } from \'@/labs/action-core\';\n\nconst navigationMenuAction: ActionDefinition = {\n  id: \'menu.navigation\',\n  title: \'Navigation Menu\',\n  icon: \'mdi-menu\',\n  // No direct handler, its purpose is to show sub-items\n  subItems: (ctx: ActionContext) => {\n    console.log(\'Fetching subItems for Navigation Menu, context:\', ctx);\n    return [\n      {\n        id: \'nav.home\',\n        title: \'Go Home\',\n        icon: \'mdi-home\',\n        handler: () => console.log(\'Navigated to Home\'),\n      },\n      {\n        id: \'nav.settings\',\n        title: \'Go to Settings\',\n        icon: \'mdi-cog\',\n        handler: () => console.log(\'Navigated to Settings\'),\n      },\n      {\n        id: \'nav.userProfile\',\n        title: \'User Profile\',\n        icon: \'mdi-account\',\n        subItems: () => [\ // Nested sub-items!\n          { id: \'user.view\', title: \'View Profile\', handler: () => {} },\n          { id: \'user.edit\', title: \'Edit Profile\', handler: () => {} },\n        ]\n      }\n    ];\n  }\n};\n```\n\n### Asynchronous Sub-Items\n\n```typescript\nimport type { ActionDefinition, ActionContext } from \'@/labs/action-core\';\n\n// Simulating an API call\nasync function fetchProjectTasks(projectId: string): Promise<ActionDefinition[]> {\n  // const response = await fetch(`/api/projects/${projectId}/tasks`);\n  // const tasks = await response.json();\n  // return tasks.map(task => ({\n  //   id: `task.view.${task.id}`,\n  //   title: `View Task: ${task.name}`,\n  //   handler: () => { /* navigate to task */ }\n  // }));\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve([\n        { id: `task.view.123`, title: `View Task: Design Homepage (Project ${projectId})`, handler: () => {} },\n        { id: `task.view.456`, title: `View Task: API Integration (Project ${projectId})`, handler: () => {} },\n      ]);\n    }, 500);\n  });\n}\n\nconst projectTasksAction: ActionDefinition = {\n  id: \'project.viewTasks\',\n  title: \'View Project Tasks\',\n  icon: \'mdi-format-list-bulleted-square\',\n  // This action might be triggered with project ID in context.data\n  subItems: async (ctx: ActionContext) => {\n    const projectId = ctx.data?.projectId;\n    if (!projectId) {\n      console.warn(\'Project ID missing for fetching tasks.\');\n      return [];\n    }\n    console.log(`Fetching tasks for project ${projectId}...\`);\n    return fetchProjectTasks(projectId);\n  }\n};\n```\n\n## UI Integration (`ShowSubItemsUISymbol`)\n\nActionCore itself does not dictate how `subItems` are displayed. It merely provides the mechanism for actions to define them. The UI component (like a command palette or a custom menu system) is responsible for:\n\n1.  Detecting that an action has a `subItems` property.\n2.  Calling the `subItems(ctx)` function, potentially passing a relevant `ActionContext`.\n3.  Handling the `Promise` if the function is asynchronous (e.g., showing a loading indicator).\n4.  Rendering the returned `ActionDefinition[]` as the next level of choices.\n\nTo facilitate this, particularly for generic components like `VBtn` that might be linked to a group action via the `command` prop, ActionCore can leverage an injection symbol: `ShowSubItemsUISymbol`. A command palette or a similar UI orchestrator can `provide` a function under this symbol. When a component (or `useCommandable`) detects it\'s trying to \"execute\" an action that primarily has `subItems`, it can inject this symbol and call the provided function, passing the parent action. This allows the central UI orchestrator to take over and display the sub-items appropriately.\n\n**Example (Conceptual - Command Palette Providing the Handler):**\n```typescript\n// In your Command Palette component\nimport { provide } from \'vue\';\nimport { ShowSubItemsUISymbol, type ActionDefinition } from \'@/labs/action-core\';\n\n// ... setup ...\nfunction displaySubItemsForAction(parentAction: ActionDefinition) {\n  // Logic to clear current palette list,\n  // call parentAction.subItems(),\n  // and display the new list, possibly pushing to an internal navigation stack.\n  openPaletteWithParent(parentAction);\n}\nprovide(ShowSubItemsUISymbol, displaySubItemsForAction);\n```\n\n## Crafting Hierarchical Actions\n\n*   **Clarity of Purpose:** Ensure your group actions have clear titles that indicate they lead to more options (e.g., \"File...\", \"Export As...\").\n*   **Contextual Relevance:** Use the `ActionContext` passed to `subItems` to make the list of sub-actions truly dynamic and relevant to the parent action\'s invocation context.\n*   **Performance of Async Sub-Items:** If `subItems` involves API calls, ensure they are efficient. Cache results where appropriate if the data doesn\'t change frequently.\n*   **User Experience:** Avoid excessively deep nesting. More than 2-3 levels can become cumbersome in most UIs. Consider alternative ways to structure or filter actions if hierarchies become too complex.\n\nSub-items are a powerful feature for creating structured and navigable command systems within your application, leading to a more organized and intuitive user experience.\n\n---\n\nNext: [**AI Integration**](./08-ai-integration.md)
